# 3-7-cache

## 1-概述

* 时间局部性:在最近的未来要用到的信息，很可能是现 在正在使用的信息 
* 空间局部性:在最近的未来要用到的信息\(指令和数据\)， 很可能与现在正在使用的信息在存储空间上是邻近的

![](../../.gitbook/assets/image%20%28117%29.png)



* 命中 
* * 主存块 调入 缓存 
  * 主存块与缓存块 建立 了对应关系 
  * 用 标记记录 与某缓存块建立了对应关系的 主存块号
* 未命中 
* * 主存块 未调入 缓存 
  * 主存块与缓存块 未建立 对应关系
* 命中率

## 2-性能分析

![](../../.gitbook/assets/image%20%28324%29.png)

## 3-cache工作原理

![](../../.gitbook/assets/image%20%2822%29.png)

![](../../.gitbook/assets/image%20%2837%29.png)

## ⭐️4-地址映射方式

### 直接映射

![](../../.gitbook/assets/image%20%28293%29.png)

### 全相联映射

![](../../.gitbook/assets/image%20%28260%29.png)

### 组相联映射

![](../../.gitbook/assets/image%20%2893%29.png)

![](../../.gitbook/assets/image%20%28173%29.png)



## 5-替换算法

*  随机算法\(RAND\):随机地确定替换的Cache块。它的实现比较简单，但没有依据程序 访问的局部性原理，故可能命中率较低。 
* 先进先出算法\(FIFO\):选择最早调入的行进行替换。它比较容易实现，但也没有依据 程序访问的局部性原理，可能会把一些需要经常使用的程序块\(如循环程序\)也作为 最早进入Cache的块替换掉。 
* 近期最少使用算法\(LRU\):依据程序访问的局部性原理选择近期内长久未访问过的存 储行作为替换的行，平均命中率要比FIFO要高，是堆栈类算法。 LRU算法对每行设置一个计数器，Cache每命中一次，命中行计数器清0，而其他各行计 数器均加1，需要替换时比较各特定行的计数值，将计数值最大的行换出。 
* 最不经常使用算法\(LFU\):将一段时间内被访问次数最少的存储行换出。每行也设置 一个计数器，新行建立后从0开始计数，每访问一次，被访问的行计数器加1，需要替 换时比较各特定行的计数值，将计数值最小的行换出。



## 6-写策略

* 写回法：当CPU对Cache写命中 时，只修改Cache的内容，而不立即写入主 存，只有当此块被换出时才写回主存
* 全写法\(写直通法）：当CPU 对Cache写命中时，必须把数据同时写入，一般使用写缓冲。
* 写分配法：把主存中的块调入Cache，在Cache中修改。搭配写回法使用。
* 非写分配法：只写入主存，不调入Cache。 搭配全写法使用。
* 
![](../../.gitbook/assets/image%20%28325%29.png)

## 7-虚拟存储器



