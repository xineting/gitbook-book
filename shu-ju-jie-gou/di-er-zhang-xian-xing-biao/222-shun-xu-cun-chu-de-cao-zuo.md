# 2-2-2-顺序存储的操作

## 1. 插入

![](../../.gitbook/assets/image%20%28109%29.png)

* 在顺序表L的第i\(1≤i≤L.length+1\)个位置插入新元素e。如果i的输入不合法，则返回false，表示插入失败; 
* 否则，将顺序表的第i个元素以及其后的所有元素右移一个位置，腾出一个空位置插入新元素e，顺序表长 度增加1，插入成功，返回true。

> **算法思路:**

1. 判断i的值是否正确
2. 判断表长是否超过数组长度3.从后向前到第i个位置，分别将这些元素都向后移动一位4.将该元素插入位置i 并修改表长

```c
bool ListInsert(SqList &L , int i , ElemType e){
    if(i<1||i>L.length+1)
        return false; 
    if(L.length>=MaxSize)
        return false; 
    for(int j=L.length ; j>=i; j--)
        L.data[j]=L.data[j-1]; 
    L.data[i-1]=e;
    L.length++; 
    return true;
}
```



* **最好情况:**在表尾插入\(即i=n+1\)，元素后移语句将不 执行，时间复杂度为O\(1\)。 
* **最坏情况:**在表头插入\(即i=1\)，元素后移语句将执行 n次，时间复杂度为O\(n\)。 
* **平均情况:**假设pi\(pi=1/\(n+1\) \)是在第i个位置上插入 一个结点的概率，则在长度为n的线性表中插入一个结 点时所需移动结点的平均次数为n/2;

线性表插入算法的平均时间复杂度为O\(n\)



## 2. 删除

* 删除顺序表L中第i\(1≤i≤L.length\)个位置的元素，成功则返回true，并将被删除的元素用引用变量 e返回，否则返回false。

算法思路:

* 1.判断i的值是否正确
* 2.取删除的元素
* 3.将被删元素后面的所有元素都依次向前移动一位
* 4.修改表长

```c
bool ListDelete(SqList &L, int i, Elemtype &e){
    if(i<1||i>L.length) 
        return false;
    e=L.data[i-1];
    for(int j=i;j<L.length;j++)
        L.data[j-1]=L.data[j]; 
        L.length--;
    return true;
}
```

* **最好情况:**删除表尾元素\(即i=n\)，无须移动元素，时间 复杂度为O\(1\)。 
* **最坏情况:**删除表头元素\(即i=1\)，需要移动除第一个元 素外的所有元素，时间复杂度为O\(n\)。 
* **平均情况:**假设pi\(pi=1/n\)是删除第i个位置上结点的概率， 则在长度为n的线性表中删除一个结点时所需移动结点的平 均次数为线性表\(n-1\)/2

**删除算法的平均时间复杂度为O\(n\)**

## 3. 总结

优点：

* 存储密度大，不需要为表中元素之间的逻辑关系增加额外存储空间
* 随机存取，可以快速存取表中任一位置的元素

缺点

* 插入和删除操作需要移动大量元素
* 对存储空间要求高，会产生存储空间的碎片

